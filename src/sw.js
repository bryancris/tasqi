
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Create a background sync queue for notifications
const notificationSyncQueue = new BackgroundSyncPlugin('notification-queue', {
  maxRetentionTime: 24 * 60 // Retry for up to 24 hours (in minutes)
});

// Custom notification click handler
self.addEventListener('notificationclick', (event) => {
  console.log('Notification clicked:', event);
  
  const notification = event.notification;
  const action = event.action;
  const notificationData = notification.data || {};
  
  // Close the notification
  notification.close();

  // Handle different notification actions
  if (action === 'done') {
    // Handle "done" action
    event.waitUntil(
      handleNotificationAction(notificationData.taskId, 'complete')
    );
  } else if (action === 'dismiss') {
    // Handle dismiss action
    event.waitUntil(
      handleNotificationAction(notificationData.taskId, 'dismiss')
    );
  } else {
    // Default click behavior - open the app
    const urlToOpen = new URL('/dashboard', self.location.origin).href;
    
    event.waitUntil(
      clients.matchAll({
        type: 'window',
        includeUncontrolled: true
      }).then((windowClients) => {
        // Check if there is already a window/tab open with the target URL
        for (var i = 0; i < windowClients.length; i++) {
          var client = windowClients[i];
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        // If no window/tab is already open, open a new one
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
    );
  }
});

// Enhanced push event handler
self.addEventListener('push', (event) => {
  console.log('Push notification received:', event);

  if (event.data) {
    try {
      const data = event.data.json();
      const options = {
        body: data.message,
        icon: '/pwa-192x192.png',
        badge: '/pwa-192x192.png',
        data: {
          taskId: data.taskId,
          timestamp: new Date().getTime(),
          type: data.type
        },
        actions: [
          {
            action: 'done',
            title: 'Done'
          },
          {
            action: 'dismiss',
            title: 'Dismiss'
          }
        ],
        vibrate: [200, 100, 200],
        tag: `task-${data.taskId}`, // Group notifications by task
        renotify: true, // Notify each time even with same tag
        requireInteraction: true // Don't auto dismiss
      };

      event.waitUntil(
        self.registration.showNotification(data.title, options)
      );
    } catch (error) {
      console.error('Error processing push notification:', error);
    }
  }
});

// Background sync handler
self.addEventListener('sync', (event) => {
  console.log('Background sync event:', event);
  
  if (event.tag === 'notification-sync') {
    event.waitUntil(syncNotifications());
  }
});

// Periodic sync handler for checking notifications
self.addEventListener('periodicsync', (event) => {
  console.log('Periodic sync event:', event);
  
  if (event.tag === 'check-notifications') {
    event.waitUntil(checkNewNotifications());
  }
});

// Handle offline notification actions
async function handleNotificationAction(taskId, action) {
  const endpoint = `/api/notifications/${action}`;
  const request = new Request(endpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ taskId })
  });

  try {
    const response = await fetch(request);
    if (!response.ok) throw new Error('Network response was not ok');
    return response;
  } catch (error) {
    // If offline, add to background sync queue
    return notificationSyncQueue.pushRequest({ request });
  }
}

// Function to sync notifications when back online
async function syncNotifications() {
  // Implementation will depend on your notification storage strategy
  console.log('Syncing notifications...');
  // Add your sync logic here
}

// Function to check for new notifications
async function checkNewNotifications() {
  // Implementation will depend on your notification checking strategy
  console.log('Checking for new notifications...');
  // Add your checking logic here
}

// Cache static assets
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache API responses
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  })
);

// Cache other static resources
registerRoute(
  ({ request }) => 
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);
